name: Generate Streak Stats

# To include private organization contributions:
# 1. Create a Personal Access Token (PAT) at https://github.com/settings/tokens/new
# 2. IMPORTANT: Select the "repo" scope (or at minimum: "read:org" and "read:user")
#    - "repo" scope gives access to all repositories (public and private)
#    - This is required to see contributions from private organization repositories
# 3. Add it as a repository secret named "GH_PAT"
#    - Go to: Repository → Settings → Secrets and variables → Actions → New repository secret
# 4. IMPORTANT: Check organization settings if contributions are still missing:
#    - Go to each organization → Settings → Third-party access
#    - Ensure "Third-party application access policy" allows your PAT
#    - Some organizations restrict third-party access even with a valid PAT
# 5. The workflow will automatically use it if available, otherwise falls back to GITHUB_TOKEN
#    - GITHUB_TOKEN only has access to public repositories

on:
  schedule:
    - cron: "0 0 * * *" # Run daily at midnight UTC
  workflow_dispatch: # Allow manual trigger
  push:
    branches:
      - main

jobs:
  generate-streak-stats:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          pip install requests

      - name: Generate Streak Stats SVG
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          python3 << 'EOF'
          import os
          import requests
          import json
          from datetime import datetime, timedelta
          import xml.etree.ElementTree as ET

          username = "Andreas-Garcia"
          theme = "radical"
          # Use PAT if available, otherwise fall back to GITHUB_TOKEN
          token = os.environ.get("GH_PAT") or os.environ.get("GITHUB_TOKEN")

          # GitHub's contribution calendar API limitation: max 1 year per query
          # To get all-time data, we query multiple 1-year ranges and combine them
          headers = {
              "Authorization": f"Bearer {token}",
              "Content-Type": "application/json"
          }

          query_template = """
          query($username: String!, $from: DateTime!, $to: DateTime!) {
            user(login: $username) {
              contributionsCollection(from: $from, to: $to) {
                contributionCalendar {
                  totalContributions
                  weeks {
                    contributionDays {
                      date
                      contributionCount
                    }
                  }
                }
              }
            }
          }
          """

          # Query multiple 1-year ranges going back in time
          # Start from today and go back in 1-year increments
          all_weeks = []
          total_contributions = 0
          max_years_back = 10  # Query up to 10 years back

          now = datetime.now()
          to_date = (now + timedelta(days=1)).isoformat() + "Z"

          print(f"Querying contributions in 1-year ranges (going back up to {max_years_back} years)...")

          for year_offset in range(max_years_back):
              from_date_obj = now - timedelta(days=365 * (year_offset + 1))
              from_date = from_date_obj.isoformat() + "Z"
              
              # For the first query (most recent year), use today as end date
              # For older queries, use the start of the next year as end date
              if year_offset == 0:
                  query_to_date = to_date
              else:
                  query_to_date = (now - timedelta(days=365 * year_offset)).isoformat() + "Z"
              
              print(f"  Querying year {year_offset + 1}: {from_date[:10]} to {query_to_date[:10]}")
              
              try:
                  response = requests.post(
                      "https://api.github.com/graphql",
                      json={
                          "query": query_template,
                          "variables": {
                              "username": username,
                              "from": from_date,
                              "to": query_to_date
                          }
                      },
                      headers=headers
                  )
                  
                  response.raise_for_status()
                  data = response.json()
                  
                  if "errors" in data:
                      error_msg = data["errors"][0].get("message", "")
                      if "must not exceed 1 year" in error_msg:
                          print(f"    ⚠ Date range too large, skipping")
                          continue
                      print(f"    ⚠ GraphQL errors: {data['errors']}")
                      continue
                  
                  contributions_collection = data["data"]["user"]["contributionsCollection"]
                  calendar = contributions_collection["contributionCalendar"]
                  year_weeks = calendar["weeks"]
                  year_total = calendar["totalContributions"]
                  
                  if not year_weeks or year_total == 0:
                      print(f"    No contributions found for this year, stopping")
                      break
                  
                  all_weeks.extend(year_weeks)
                  total_contributions = max(total_contributions, year_total)  # Use max as it might be cumulative
                  print(f"    ✓ Found {year_total} contributions, {len(year_weeks)} weeks")
                  
              except Exception as e:
                  print(f"    ⚠ Error querying year {year_offset + 1}: {e}")
                  if year_offset == 0:
                      # If the first query fails, fall back to query without dates
                      print("    Falling back to query without date restrictions...")
                      query_no_dates = """
                      query($username: String!) {
                        user(login: $username) {
                          contributionsCollection {
                            contributionCalendar {
                              totalContributions
                              weeks {
                                contributionDays {
                                  date
                                  contributionCount
                                }
                              }
                            }
                          }
                        }
                      }
                      """
                      response2 = requests.post(
                          "https://api.github.com/graphql",
                          json={"query": query_no_dates, "variables": {"username": username}},
                          headers=headers
                      )
                      response2.raise_for_status()
                      data2 = response2.json()
                      if "errors" not in data2:
                          contributions_collection = data2["data"]["user"]["contributionsCollection"]
                          calendar = contributions_collection["contributionCalendar"]
                          all_weeks = calendar["weeks"]
                          total_contributions = calendar["totalContributions"]
                          print("    ✓ Fallback query successful")
                      break
                  else:
                      # For older years, just skip if there's an error
                      break

          if not all_weeks:
              raise Exception("No contribution data found")

          print(f"Successfully queried contributions: {len(all_weeks)} total weeks")

          # Combine all weeks and deduplicate by date (in case of overlaps)
          contributions_by_date = {}
          for week in all_weeks:
              for day in week["contributionDays"]:
                  date_str = day["date"]
                  try:
                      date_obj = datetime.strptime(date_str, "%Y-%m-%d").date()
                  except:
                      date_obj = datetime.fromisoformat(date_str.replace("Z", "")).date()
                  count = day["contributionCount"]
                  # If date already exists, use the maximum count (handles overlaps)
                  if date_obj in contributions_by_date:
                      contributions_by_date[date_obj] = max(contributions_by_date[date_obj], count)
                  else:
                      contributions_by_date[date_obj] = count

          # Rebuild weeks structure from combined data
          # Group by week (starting from Monday)
          weeks = []
          if contributions_by_date:
              sorted_dates = sorted(contributions_by_date.keys())
              first_date = sorted_dates[0]
              # Find the Monday of the week containing the first date
              days_since_monday = first_date.weekday()
              week_start = first_date - timedelta(days=days_since_monday)
              
              current_week_start = week_start
              current_week_days = []
              
              for date_obj in sorted_dates:
                  # If this date is beyond the current week, start a new week
                  while date_obj >= current_week_start + timedelta(days=7):
                      if current_week_days:
                          weeks.append({"contributionDays": current_week_days})
                      current_week_start += timedelta(days=7)
                      current_week_days = []
                  
                  # Add this day to the current week
                  current_week_days.append({
                      "date": date_obj.isoformat(),
                      "contributionCount": contributions_by_date[date_obj]
                  })
              
              # Add the last week
              if current_week_days:
                  weeks.append({"contributionDays": current_week_days})

          # Recalculate total from combined data
          manual_total = sum(contributions_by_date.values())
          total_contributions = manual_total

          print(f"Combined data: {len(contributions_by_date)} unique days, {manual_total} total contributions")

          # Debug: Check which token is being used
          token_type = "PAT (GH_PAT)" if os.environ.get("GH_PAT") else "GITHUB_TOKEN (limited)"
          print(f"Using token type: {token_type}")

          # Verify token permissions by checking user info
          try:
              user_check = requests.get(
                  "https://api.github.com/user",
                  headers={"Authorization": f"Bearer {token}"}
              )
              user_check.raise_for_status()
              user_data = user_check.json()
              print(f"Authenticated as: {user_data.get('login', 'unknown')}")
              print(f"Token has repo access: {'repo' in str(user_check.headers.get('X-OAuth-Scopes', ''))}")
          except Exception as e:
              print(f"Warning: Could not verify token permissions: {e}")

          # Debug: Print contribution info
          print(f"Total contributions (combined): {total_contributions:,}")
          print(f"Number of weeks: {len(weeks)}")

          # Count total days with contributions
          total_days_with_contributions = sum(1 for count in contributions_by_date.values() if count > 0)
          print(f"Days with contributions: {total_days_with_contributions}")

          # Calculate current streak
          today = datetime.now().date()
          current_streak = 0
          longest_streak = 0

          # contributions_by_date is already built from combined data
          all_dates = sorted(contributions_by_date.keys())

          if not all_dates:
              raise Exception("No contribution data found")

          # all_dates is already sorted from the combined data
          most_recent_date = all_dates[-1]
          today = datetime.now().date()

          # Calculate current streak: count backwards from today
          # A streak continues as long as there are contributions on consecutive days
          # Start from today and go backwards day by day
          check_date = today

          # Count backwards from today
          # Stop if we go too far back (more than a reasonable time) or hit a day with no contributions
          max_days_back = 1000  # Safety limit
          days_checked = 0

          while days_checked < max_days_back:
              # If date is in our data
              if check_date in contributions_by_date:
                  if contributions_by_date[check_date] > 0:
                      # This day has contributions, add to streak and continue
                      current_streak += 1
                      check_date = check_date - timedelta(days=1)
                      days_checked += 1
                  else:
                      # This day has 0 contributions, streak is broken
                      break
              else:
                  # Date is not in our data
                  # If it's before our earliest date, stop
                  if check_date < all_dates[0]:
                      break
                  # If it's today and not in data, it might be too early (check yesterday)
                  if check_date == today:
                      check_date = check_date - timedelta(days=1)
                      days_checked += 1
                      continue
                  # Otherwise, this day had no contributions (not in our data), streak is broken
                  break

          # Calculate longest streak: go through all dates chronologically
          temp_streak = 0
          for date_obj in sorted(contributions_by_date.keys()):
              if contributions_by_date[date_obj] > 0:
                  temp_streak += 1
                  longest_streak = max(longest_streak, temp_streak)
              else:
                  temp_streak = 0

          print(f"Most recent contribution date: {most_recent_date}")
          print(f"Current streak: {current_streak} days")
          print(f"Longest streak: {longest_streak} days")

          # Theme colors (radical theme)
          colors = {
              "bg": "#0d1117",
              "border": "#e4e2e2",
              "text": "#e4e2e2",
              "title": "#ff6e96",
              "streak": "#ff6e96",
              "total": "#ff6e96"
          }

          # Generate SVG
          svg_width = 495
          svg_height = 195

          svg = ET.Element("svg", {
              "width": str(svg_width),
              "height": str(svg_height),
              "xmlns": "http://www.w3.org/2000/svg"
          })

          # Background
          bg = ET.SubElement(svg, "rect", {
              "width": str(svg_width),
              "height": str(svg_height),
              "fill": colors["bg"]
          })

          # Title
          title = ET.SubElement(svg, "text", {
              "x": str(svg_width // 2),
              "y": "30",
              "text-anchor": "middle",
              "font-family": "Segoe UI, sans-serif",
              "font-size": "20",
              "font-weight": "bold",
              "fill": colors["title"]
          })
          title.text = "GitHub Streak Stats"

          # Current Streak
          streak_text = ET.SubElement(svg, "text", {
              "x": "50",
              "y": "80",
              "font-family": "Segoe UI, sans-serif",
              "font-size": "14",
              "fill": colors["text"]
          })
          streak_text.text = "Current Streak:"

          streak_value = ET.SubElement(svg, "text", {
              "x": "200",
              "y": "80",
              "font-family": "Segoe UI, sans-serif",
              "font-size": "14",
              "font-weight": "bold",
              "fill": colors["streak"]
          })
          streak_value.text = f"{current_streak} days"

          # Longest Streak
          longest_text = ET.SubElement(svg, "text", {
              "x": "50",
              "y": "110",
              "font-family": "Segoe UI, sans-serif",
              "font-size": "14",
              "fill": colors["text"]
          })
          longest_text.text = "Longest Streak:"

          longest_value = ET.SubElement(svg, "text", {
              "x": "200",
              "y": "110",
              "font-family": "Segoe UI, sans-serif",
              "font-size": "14",
              "font-weight": "bold",
              "fill": colors["streak"]
          })
          longest_value.text = f"{longest_streak} days"

          # Total Contributions
          total_text = ET.SubElement(svg, "text", {
              "x": "50",
              "y": "140",
              "font-family": "Segoe UI, sans-serif",
              "font-size": "14",
              "fill": colors["text"]
          })
          total_text.text = "Total Contributions:"

          total_value = ET.SubElement(svg, "text", {
              "x": "200",
              "y": "140",
              "font-family": "Segoe UI, sans-serif",
              "font-size": "14",
              "font-weight": "bold",
              "fill": colors["total"]
          })
          total_value.text = f"{total_contributions:,}"

          # Save SVG
          tree = ET.ElementTree(svg)
          ET.indent(tree, space="  ")
          tree.write("streak-stats.svg", encoding="utf-8", xml_declaration=True)

          print(f"Generated streak stats: {current_streak} day streak, {longest_streak} longest, {total_contributions} total")
          EOF

      - name: Commit and push SVG
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add streak-stats.svg
          git diff --staged --quiet || git commit -m "Update streak stats [skip ci]"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
